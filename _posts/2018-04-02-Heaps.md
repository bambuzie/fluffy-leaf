---
layout: post
title: Heaps
key: 20170606
tags:
  - Data Structure
  - Heaps
  - Trees
  - Arrays
  - Primary Queue
  - Binary Sort
  - English
mermaid: true
---

## Definition:

Heaps are a binary tree with a structural property in which all heaps are a complete binary tree (when coded we dont use linked lists with left and right pointers, rather we trace through an array and manipulating the array as if it was a complete binary tree. Heaps also must also have all of its nodes in a specific order, following the heap order property. <br>

What makes a heap, a heap? First, ask yourself this...

<!--more-->

```mermaid
graph TD
A(Is the tree <b>*</b>complete?);
A -->|Yes| B(Are the root's children >= it, a minheap, or <= it, a maxheap?);
A -->|No| C[not a heap];
B -->|Yes| D[ heap yeah!];
B -->|No| E[ not at heap];

```
* All of the levels of the tree must be filled completely except maybe the last one. <br>
    |> must have the **left-most** nodes **always** filled.

---



## Growing and Shrinking 
When we insert or delete from a heap it is important to remember to not violate any of the heap's properties when manipulating the tree.
If we are inserting something into the tree it is important to note that we can only insert a node at the bottom(lowest) left most position in the tree.
Once we insert something into the tree you have to check and verify that it follows the heap code.

```
Here is a sample minheap 

        (56)
        /  \
      (67) (98)
      /
    (78)

insert(45)

        (56)
        /  \
      (67) (98)
      /  \
    (78) (45) <-- lowest left most position
    
Now that we inserted our value or key, since the leaf node, (45), is smaller than its parent and root,
it violates the heap code and we would have to **percolate up** swap the child with its parent until 
it satifies the minheap property!

        (56)
        /  \
      (45) (98)     *swaps*
      /  \
    (78) (67)
    
        (45)        *swaps*
        /  \
      (56) (98)
      /  \
    (78) (67)
    
Yay! It's a minheap again!
We continued swapping until the parent is smaller than the key we are percolating upwards. 

```
With minheaps you can imagine that you have a lot of responsibilites on your hands. Now separate your tasks from 
least important to most important. The larger numerical values signifying the more significant tasks you want to bring forward in order of importance whereas the small,
quick tasks you can push back (closer to the root) to be completed later. 

The same strategy from above applies to maxheaps except the logic is inverted. The maximum value would be at the root and its children would be <= to the root. 

---
From what we just learned, the only position we can insert a key is at a specific location to maintain the heaps structure and properties.<br>
What if we want to shrink our heap? a.k.a, delete it. 

```
Deletion example with a maxheap. 

        ( 340 )
        /      \
    (230)     (198)     
    /   \     /   \
(178) (167) (145) (190)

delete(root)    Note: with deletion, in order to maintain the heap structure we can only delete from 
                      the root, we are unable to delete a random value. Generally when you want to 
                      delete from a heap, it is always either the maxheap or minheap,otherwise, if 
                      you want to delete some arbitrary value other than root then maybe user a 
                      different data structure. 

        (  X  )     <----- *poof* deleted
        /      \
    (230)     (198)     
    /   \     /   \
(178) (167) (145) (190)


        (  X  )             *still want to follow the heap code, what should we do next?
        /      \
    (230)     (198)     
    /   \     /   \
(178) (167) (145) (190)


        ( 190 )             
        /      \
    (230)     (198)     
    /   \     /         <--- took lowest, left leaf and placed it at the root. 
(178) (167) (245) 

Now that we satisfied the first property, we move onto the second strucutral property and perform some swaps
to get the max value at the root.

        ( 230 )         *swaps* 
        /      \
    (190)     (198)     
    /   \     /   
(178) (167) (145) 

```
```

What if the children of the root are both the same? How can we figure out which path to take downwards?


```


## Applications 

## Heapsort and Heapify 

## Time and Space Complexity
### height
> "We define the height of a node in a tree to be the number of edges on the longest simple downward path from the node to a leaf, and we define the height of the tree to be the height of its >root. Since a heap of n elements is based on a complete binary tree, its height is (lg n) (see Exercise 7.1-2). We shall see that the basic operations on heaps run in time at most proportional >to the height of the tree and thus take O(lg n) time."

>source(http://net.pku.edu.cn/~course/cs101/2007/resource/Intro2Algorithm/book6/chap07.htm)



### TLDR;

## Lets code it up!

### Glossary and Sources
