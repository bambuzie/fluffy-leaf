---
layout: post
title: Tries
key: 20160616
tags:
  - Data Structure
  - Tries
  - Radix Tree
  - English
---
## **Definition:** 

A Trie is a static tree-like data structure in which each node has 26 children pointers representing the letters of the English alphabet. The strings or words can be re**trie**ved by traversing down a branch path of the tree. When traversing down a path the count will indicate if the string is a word and count its popularity.

{% highlight C Language linenos %}
typedef struct trieNode
{
    int count; 
    struct trieNode *children[26];
} trieNode;
{% endhighlight %}


<!--more-->
### Adantages
* Unlike a BST, trie's do not store strings or keys associated with that node, instead its position in the tree defines what the key is linked with. 
* Storing strings in a BST is a O(klog(n)) where k is the length of the string and n is the total amount of strings we need to go through.
* There are no collisions of different keys in a trie and **no need to provide hash functions in a trie**.
* Tries use arrays and pointers - hash tables use arrays and linked lists.
* Tries make it easy to search for a subset of elements, similar to BST, each time we traverse down a branch of a tree, we cut out the number of nodes we need to look at. 
{:.success}

### Disadvantages 
* A hash takes up a lot of memory and space. 
{:.warning}
* Some tries can have long chains and prefixes that are not meaningful. 
{:.warning}


## Basic Structure

```
To start off, the root node of a trie is empty with 26 links
to other nodes - one for each possible alphabetical value and so on.

The shape and structure of a trie is always a set of linked nodes,
all connecting back to an empty root node.

The root has an array of 26 pointers that all point to null at first and as the trie grows,
those pointers start to get filled up with references to other nodes and so on. 

        (" ")
        / | \     <---- 26 links 
       A..K..Z    <---- Here, each node of the root are represented
                        as letters however when coding this up, to access 
                        the index, need CHAR_TO_INDEX(x)    ((int)x - (int)'a') 
                        
                        **For example** inserting the letter 'a' from "acquiesce" 
                        will convert it to the value 0. These characters(a,b,c..) 
                        live at those indexs(0,1,2..) since our root node will hold 
                        an array of indexes 0 through 25, and there are 26 possible 
                        slots for the 26 letters of the alphabet.
                        
                        See conversion/reference chart. 
    
An array representation would look like this -

+----------------------------------------------------------------------------------------------+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |... | 26 |
+----------------------------------------------------------------------------------------------+
                                           \ 
                                    +-------------------------------+
                                    | 0 |...| 14 | 15 | 16 |...| 26 | <--- malloced that shit
                                    +-------------------------------+
                                                 /
                                    +-------------------------------+
                                    | 0 |...| 17 | 18 | 19 |...| 26 |
                                    +-------------------------------+
This word spells out "kor"
The rest of the pointers are NULL.
                        
   
```
* The size of a trie is directly connected to the size of the alphabet that is being represented. 
* Each node contains an array of references (as pictured above) and the characters are defined by its corresponding value, a.k.a index, in the array. 
* All the descendants of a node have a common prefix of the string associated wit that node. 
* **As a trie grows in size, less work must be done to add a value, since the "intermediate nodes" or branches of the trie have already been built up.**

---

### Conversion Chart

```
+=======================================================================================================================+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 |
------------------------------------------------------------------------------------------------------------------------+
| A | B | C | D | E | F | G | H | I | J |  K |  L |  M |  N |  O |  P |  Q |  R |  S |  T |  U |  V |  W |  X |  Y |  Z |
+=======================================================================================================================+
```

## Applications 

Tries have many uses such as storing an autocomplete dictionary, can be used as a spell checker and 
store frequency of words and autocomplete senteces. For instance when you type into the Google search bar 
it will autocomplete words for you based on popularity or perform a **text prediction** operation that will 
enable the trie to fill in sentences for you based on what you recently type after a specific word. 
There are three common applications for using a trie; insert, deletion and search. 

### Text Prediction

Implementing text prediction would look similar to this using this corpus.
```
I like dancing
I like food
She goes swimming
She likes swimming 
```

Here's what the trie looks like after inserting the words from the corpus
![](https://image.ibb.co/ndmN27/pic1.jpg) 

I color coded each leaf that correlates to the the words subtree as shown in the next photo.
This is somewhat the visual of the word's subtree looks like when implementing text prediction. 

![](http://i63.tinypic.com/20kovbq.jpg)

### Insertion

When inserting into a trie you start at the root and check to see if the character corresponding
to the index is not null, if it is that means that the word does not exist so you need to malloc
for the node until after the last letter of the string. 

```
Example:
    
Word: panic

    (   ) <---- empty root node, malloc space at index 15
            
    (   ) 
        \
         P      <---- continue the process
         |
         a
         |
         n
         |
         i
         |
         c
            

```
You repeat this process for insertion and if you want to insert another word that begins with 'p' you 
start at the root node, index[15] which correlates with the character p has space so you malloc from
that node rather than the root.

Here's the logic translated into code:

{% highlight C Language linenos %}
// key here is our string or word
trieNode *insert(trieNode *root, char *key)
{
    int i, len = strlen(key), index = 0;
    
    if (root == NULL)
        return createNode();
        
    trieNode *trace = NULL;
    trace = root;
    
    for (i = 0; i < ALPHABET_SIZE; i++)
    {
        index = tolower(key[i]);
        index = CHAR_TO_INT(key[i]);
        
        if (trace->children[index] == NULL)
            trace->children[index] = createNode();
        trace = trace->children[index];
    }
    
    trace->count++;
    trace->isLeaf = true;
    return trace;
        
}
{% endhighlight %}

### Deletion
When deleting from the trie, first you must go back and check to see if the node exists from the root and if not there is nothing to delete.
If the count is > 1 then decrement the value by one.
If the node has children just set the count back to 0.
Otherwise go back up the chain towards the root and deleting each node in a bottom up manner (recursion) until
you hit a node with count > 0 or a node that has at least one child.

{% highlight C Language linenos %}
// deletion code here
{% endhighlight %}

### Search

{% highlight C Language linenos %}
// search code here
{% endhighlight %}

## Time complexity

Worst case runtime for a trie is dependant on how many words the trie contains and the length of each word. 
In this case the time complexity would be O(m*n) with m being the longest word and n is the total number of words. 
In the case of insertion all of the cases are O(k) with k being the length of the word you are trying to insert. For
deletion and search the runtime would be similar to insertion however their best case would be O(1) runtime in a
scenario a user would want to look up or delete a word that does not exist within the trie. 

---

### TLDR;

|-----------------+------------+-----------------+----------------|
|   Operations    | Worst Case |    Best Case    |  Average Case  |
|-----------------|:-----------|:---------------:|---------------:|
|   Insertion     |    O(k)    |      O(k)       |      O(k)      |
|   Deletion      |    O(k)    |      O(1)       |      O(k)      |
|   Search        |    O(k)    |      O(1)       |      O(k)      |
|=================+============+=================+================|
|                 |            |                 |                |
|-----------------+------------+-----------------+----------------|

>*k represents the length of the string


## Lets code it up!

Full C code of a trie implementation while keeping it case sensitive. 

{% highlight C Language linenos %}
// Sara Aladham
// 4/1/2018

#include <stdio.h>
#include <stdlib.h>

typedef struct trieNode
{
    int count; 
    struct trieNode *children[26];
} trieNode;
{% endhighlight %}

 
### Glossary
* **Search Miss**: could not find value for key
* **Search Hit**:  able to find value for key
* **Lexicon**: all the valid words in the dictionary
* **Corpus**: body of text
* **Intermediate**: coming inbetween time,place,order and so on. (middle)

---

> information and references came from [this](https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014) resource.
