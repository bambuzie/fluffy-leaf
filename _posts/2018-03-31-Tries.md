---
layout: post
title: Tries
key: 20160616
tags:
  - Data Structure
  - Tries
  - Radix Tree
  - English
---
## **Definition:** 

A Trie is a static tree-like data structure in which each node has 26 children pointers representing the letters of the English alphabet. The strings or words can be re**trie**ved by traversing down a branch path of the tree. When traversing down a path the count will indicate if the string is a word and count its popularity.

{% highlight C Language linenos %}
typedef struct trieNode
{
    int count; 
    struct trieNode *children[26];
} trieNode;
{% endhighlight %}


<!--more-->
### Adantages

### Disadvantages 

## Basic Structure

```
To start off, the root node of a trie is empty with 26 links
to other nodes - one for each possible alphabetical value and so on.

The shape and structure of a trie is always a set of linked nodes,
all connecting back to an empty root node.

The root has an array of 26 pointers that all point to null at first and as the trie grows,
those pointers start to get filled up with references to other nodes and so on. 

        (" ")
        / | \     <---- 26 links 
       A..K..Z    <---- Here, each node of the root are represented
                        as letters however when coding this up, to access 
                        the index, need CHAR_TO_INDEX(x)    ((int)x - (int)'a') 
                        
                        **For example** inserting the letter 'a' from "acquiesce" 
                        will convert it to the value 0. These characters(a,b,c..) 
                        live at those indexs(0,1,2..) since our root node will hold 
                        an array of indexes 0 through 25, and there are 26 possible 
                        slots for the 26 letters of the alphabet.
                        
                        See conversion/reference chart. 
    
An array representation would look like this -

+----------------------------------------------------------------------------------------------+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |... | 26 |
+----------------------------------------------------------------------------------------------+
                                           \ 
                                    +-------------------------------+
                                    | 0 |...| 14 | 15 | 16 |...| 26 | <--- malloced that shit
                                    +-------------------------------+
                                                 /
                                    +-------------------------------+
                                    | 0 |...| 17 | 18 | 19 |...| 26 |
                                    +-------------------------------+
This word spells out "kor"
The rest of the pointers are NULL.
                        
   
```
* The size of a trie is directly connected to the size of the alphabet that is being represented. 
* Each node contains an array of references (as pictured above) and the characters are defined by its corresponding value, a.k.a index, in the array. 
* All the descendants of a node have a common prefix of the string associated wit that node. 
* **As a trie grows in size, less work must be done to add a value, since the "intermediate nodes" or branches of the trie have already been built up.**

---

### Conversion Chart

```
+=======================================================================================================================+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 |
------------------------------------------------------------------------------------------------------------------------+
| A | B | C | D | E | F | G | H | I | J |  K |  L |  M |  N |  O |  P |  Q |  R |  S |  T |  U |  V |  W |  X |  Y |  Z |
+=======================================================================================================================+
```

## Applications 

Tries have many uses such as storing an autocomplete dictionary, can be used as a spell checker and 
store frequency of words and autocomplete senteces. For instance when you type into the Google search bar 
it will autocomplete words for you based on popularity or perform a **text prediction** operation that will 
enable the trie to fill in sentences for you based on what you recently type after a specific word. 
There are three common applications for using a trie; insert, deletion and search. 

### Text Prediction

Implementing text prediction would look similar to this using this corpus.
```
I like dancing
I like food
She goes swimming
She likes swimming 
```

Here's what the trie looks like after inserting the words from the corpus
![](https://image.ibb.co/ndmN27/pic1.jpg) 

I color coded each leaf that correlates to the the words subtree as shown in the next photo.
This is somewhat the visual of the word's subtree looks like when implementing text prediction. 

![](http://i63.tinypic.com/20kovbq.jpg)

### Insertion

When inserting into a trie you start at the root and check to see if the character corresponding
to the index is not null, if it is that means that the word does not exist so you need to malloc
for the node until after the last letter of the string. 

```
Example:
    
Word: panic

    (   ) <---- empty root node, malloc space at index 15
            
    (   ) <---- continue to process
        \
         P
         |
         a
         |
         n
         |
         i
         |
         c
            

```
You repeat this process for insertion and if you want to insert another word that begins with 'p' you 
start at the root node, index[15] which correlates with the character p has space so you malloc from
that node rather than the root.

Here's the logic translated into code:

{% highlight C Language linenos %}
// key here is our string or word
trieNode *insert(trieNode *root, char *key)
{
    int i, len = strlen(key), index = 0;
    
    if (root == NULL)
        return createNode();
        
    trieNode *trace = NULL;
    trace = root;
    
    for (i = 0; i < ALPHABET_SIZE; i++)
    {
        index = tolower(key[i]);
        index = CHAR_TO_INT(key[i]);
        
        if (trace->children[index] == NULL)
            trace->children[index] = createNode();
        trace = trace->children[index];
    }
    
    trace->count++;
    trace->isLeaf = true;
    return trace;
        
}
{% endhighlight %}

### Deletion
When deleting from the trie, first you must go back and check to see if the node exists from the root and if not there is nothing to delete.
If the count is > 1 then decrement the value by one.
If the node has children just set the count back to 0.
Otherwise go back up the chain towards the root and deleting each node in a bottom up manner (recursion) until
you hit a node with count > 0 or a node that has at least one child.

### Search

## Time complexity

Electroencephalography (EEG) is an electrophysiological monitoring method to record electrical activity of the brain. It is typically noninvasive, with the electrodes placed along the scalp, although invasive electrodes are sometimes used such as in electrocorticography. EEG measures voltage fluctuations resulting from ionic current within the neurons of the brain. In clinical contexts, EEG refers to the recording of the brain's spontaneous electrical activity over a period of time, as recorded from multiple electrodes placed on the scalp. Diagnostic applications generally focus either on event-related potentials or on the spectral content of EEG. The former investigates potential fluctuations time locked to an event like stimulus onset or button press. The latter analyses the type of neural oscillations (popularly called "brain waves") that can be observed in EEG signals in the frequency domain.


### TLDR;

|-----------------+------------+-----------------+----------------|
|   Operations    | Worst Case |    Best Case    |  Average Case  |
|-----------------|:-----------|:---------------:|---------------:|
|   Insertion     |    O(k)    |      O(k)       |      O(k)      |
|   Deletion      |    O(k)    |      O(1)       |      O(k)      |
|   Search        |    O(k)    |      O(1)       |      O(k)      |
|=================+============+=================+================|
|                 |            |                 |                |
|-----------------+------------+-----------------+----------------|

>*k represents the length of the string

---

## Lets code it up!

{% highlight C Language linenos %}
// Sara Aladham
// 4/1/2018

#include <stdio.h>
#include <stdlib.h>

typedef struct trieNode
{
    int count; 
    struct trieNode *children[26];
} trieNode;
{% endhighlight %}

o averaged EEG responses that are time-locked to more complex processing of stimuli; this technique is used in cognitive science, cognitive psychology, and psychophysiological research.
 
### Glossary
* **Search Miss**: could not find value for key
* **Search Hit**:  able to find value for key
* **Lexicon**: all the valid words in the dictionary
* **Corpus**: body of text
* **Intermediate**: coming inbetween time,place,order and so on. (middle)

